#pragma once

#include <cmath>

// Generated by AI
template<typename T>
struct vec3 {
    using value_type = T;

    T x{0};
    T y{0};
    T z{0};

    constexpr vec3() = default;
    constexpr vec3(const T x, const T y, const T z) : x(x), y(y), z(z) {}
    constexpr vec3(const vec3<T>& other) : x(other.x), y(other.y), z(other.z) {}

    constexpr vec3 operator+(const vec3& other) const {
        return {x + other.x, y + other.y, z + other.z};
    }

    constexpr vec3 operator-(const vec3& other) const {
        return {x - other.x, y - other.y, z - other.z};
    }

    constexpr vec3 operator*(const vec3& other) const {
        return {x * other.x, y * other.y, z * other.z};
    }

    constexpr vec3 operator/(const vec3& other) const {
        return {x / other.x, y / other.y, z / other.z};
    }

    constexpr vec3 operator+(const T& scalar) const {
        return {x + scalar, y + scalar, z + scalar};
    }

    constexpr vec3 operator-(const T& scalar) const {
        return {x - scalar, y - scalar, z - scalar};
    }

    constexpr vec3 operator*(const T& scalar) const {
        return {x * scalar, y * scalar, z * scalar};
    }

    constexpr vec3 operator/(const T& scalar) const {
        return {x / scalar, y / scalar, z / scalar};
    }

    // Generated by AI, may be copied from github.com/E-Rockalanche/Raytracer
    constexpr vec3& operator+=(const vec3& other) {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }

    constexpr vec3& operator-=(const vec3& other) {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return *this;
    }

    constexpr vec3& operator*=(const vec3& other) {
        x *= other.x;
        y *= other.y;
        z *= other.z;
        return *this;
    }

    constexpr vec3& operator/=(const vec3& other) {
        x /= other.x;
        y /= other.y;
        z /= other.z;
        return *this;
    }

    constexpr vec3& operator+=(const T& scalar) {
        x += scalar;
        y += scalar;
        z += scalar;
        return *this;
    }

    constexpr vec3& operator-=(const T& scalar) {
        x -= scalar;
        y -= scalar;
        z -= scalar;
        return *this;
    }

    constexpr vec3& operator*=(const T& scalar) {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }

    constexpr vec3& operator/=(const T& scalar) {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        return *this;
    }
    // End code potentially copied by AI from github.com/E-Rockalanche/Raytracer

    constexpr T magnitude() const {
        return std::sqrt(x * x + y * y + z * z);
    }

    constexpr friend vec3 operator+(const T& scalar, const vec3& v) {
        return v + scalar;
    }

    constexpr friend vec3 operator-(const T& scalar, const vec3& v) {
        return {scalar-v.x, scalar-v.y, scalar-v.z};
    }

    constexpr friend vec3 operator*(const T& scalar, const vec3& v) {
        return v * scalar;
    }

    constexpr friend vec3 operator/(const T& scalar, const vec3& v) {
        return {scalar/v.x, scalar/v.y, scalar/v.z};
    }
    
    constexpr friend vec3 abs(const vec3<T>& initial) {
        return {
            std::abs(initial.x), 
            std::abs(initial.y), 
            std::abs(initial.z)
        };
    }

    constexpr friend vec3 normalize(const vec3<T>& initial) {
        const auto magnitude = std::sqrt(initial.x * initial.x + initial.y * initial.y + initial.z * initial.z);
        if (magnitude == 0) {
            return {0, 0, 0};
        }
        return {
            initial.x / magnitude,
            initial.y / magnitude,
            initial.z / magnitude
        };
    }

    constexpr vec3 normalize() const {
        return normalize(*this);
    }

};
